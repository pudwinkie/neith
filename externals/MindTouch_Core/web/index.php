<?php
/*
 * MindTouch Deki - enterprise collaboration and integration platform
 *  derived from MediaWiki (www.mediawiki.org)
 * Copyright (C) 2006-2009 MindTouch, Inc.
 * www.mindtouch.com  oss@mindtouch.com
 *
 * For community documentation and downloads visit www.opengarden.org;
 * please review the licensing section.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 * http://www.gnu.org/copyleft/gpl.html
 */

#apd_set_pprof_trace();
# Main wiki script; see design.doc
#
$wgRequestTime = microtime();
unset( $IP );
@ini_set( 'allow_url_fopen', 0 ); # For security...

if (!file_exists( 'LocalSettings.php' ) || filesize( 'LocalSettings.php' ) <=0) {
	header('Location: config/index.php');
	exit();
}

// Valid web server entry point, enable includes.
define('MINDTOUCH_DEKI', true);
require_once( 'includes/Defines.php' );
require_once( 'LocalSettings.php' );
require_once( 'includes/Setup.php' );

wfProfileIn('main-load-plugins');
// (guerrics) handles loading plugins and calling hooks
require_once($IP . $wgDekiPluginPath . '/deki_plugin.php');
// load plugins
DekiPlugin::loadSitePlugins();
wfProfileOut('main-load-plugins');

wfProfileIn( 'main-misc-setup' );

OutputPage::setEncodings(); # Not really used yet

// Use DekiRequest here so that we can access button values
$action = DekiRequest::getInstance()->getVal('action', 'view');

$title = $wgRequest->getVal( 'title' );
$action = strtolower( $action );
if ($wgRequest->getVal( 'printable' ) == 'yes') {
	$wgOut->setPrintable();
}

if ( wfHomePageInternalTitle() == $title && 'delete' != $action ) {
	$wgTitle = Title::newFromText( wfHomePageInternalTitle() );
}
elseif ( $curid = $wgRequest->getInt( 'curid' ) ) {
	# URLs like this are generated by RC, because rc_title isn't always accurate
	$wgTitle = Title::newFromID( $curid );
}
else {
	if ($contextID = $wgRequest->getInt( 'contextid' ))
	$wgTitle = Title::newFromURL( $title, Title::newFromID( $contextID ) );
	else
	$wgTitle = Title::newFromURL( $title );
}

// invalid title needs to fail early; see bug #6279
if (is_null($wgTitle))
{
	$wgTitle = Title::newFromText( wfMsgForContent('Article.Error.input-bad-title') );
	$wgOut->errorpage('Article.error.badtitle', 'Article.Error.page-title-is-invalid', htmlspecialchars($title));
	exit();
}

// TODO: (guerrics) remove this temporary check
if ($wgTitle->getNamespace() == NS_ADMIN)
{
	$Title = Title::makeTitle(NS_SPECIAL, 'Admin');
	$wgOut->redirect($Title->getLocalUrl());

	// redirect immediately
	$wgOut->output();
	exit();
}

// allow plugins to hook into custom titles or modify the title object
wfProfileIn('main-plugin-INDEX_PROCESS_TITLE');
DekiPlugin::executeHook(Hooks::MAIN_PROCESS_TITLE, array($wgRequest, $wgTitle));
wfProfileOut('main-plugin-INDEX_PROCESS_TITLE');

wfProfileOut( 'main-misc-setup' );
wfProfileIn( 'main-action' );

$search = $wgRequest->getText( 'search' );
if ( !is_null( $search ) && $search !== '' ) {
	$wgTitle = Title::makeTitle( NS_SPECIAL, 'Search' );
}

if ( !$wgTitle ) {
	$wgTitle = Title::newFromText( wfMsgForContent('Article.Error.input-bad-title') );
	$wgOut->errorpage('badtitle', 'Article.Error.page-title-is-invalid');
} else if ( $wgTitle->getInterwiki() != '' ) {
	$url = $wgTitle->getFullURL();
	# Check for a redirect loop
	if ( !preg_match( '/^' . preg_quote( $wgServer, '/' ) . '/', $url ) ) {
		$wgOut->redirect( $url );
	} else {
		$wgTitle = Title::newFromText( wfMsgForContent('Article.Error.input-bad-title') );
		$wgOut->errorpage('badtitle', 'Article.Error.page-title-is-invalid');
	}
} else if ( ( $action == 'view' ) &&
(!isset( $_GET['title'] ) || strcasecmp(rawurldecode($wgTitle->getPrefixedDBKey()), $_GET['title']) != 0 ) &&
!count( array_diff( array_keys( $_GET ), array( 'action', 'title' ) ) ) )
{
	$wgOut->redirect( $wgTitle->getFullURL(), '301');
}
else
{
	if (!empty($wgPreloadPages))
	{
		$articleId = $wgTitle->getArticleId();
		foreach ($wgPreloadPages as $page)
		{
			$at = new Article(Title::newFromText($page));
			$at->mTargetArticleId = $articleId;
			$at->loadContent();
		}
	}
	
	// variables used to avoid large conditionals
	$specialPluginResult = 0;
	$dashboardPluginResult = 0;
	if (NS_SPECIAL == $wgTitle->getNamespace())
	{
		// actions that need to be made when we have a special pages
		$bits = split("/", $wgTitle->getDBkey(), 2);
		$name = $bits[0];
		if (!isset($bits[1])) // bug 2087
		{
			$par = NULL;
		}
		else
		{
			$par = $bits[1];
		}

		// fire a special page dispatcher
		$specialPluginResult = DekiPlugin::executeHook(Hooks::SPECIAL_PAGE, array($name));
	}
	else if ($action == 'view'
			// we're on a dashboard page (/User:Admin)
			&& NS_USER == $wgTitle->getNamespace()
			&& (strlen($wgTitle->getPartialURL()) > 0)
			&& (strpos($wgTitle->getPrefixedURL(), '/') === false)
			// not a diff view
			&& is_null($wgRequest->getVal('diff'))
			// not a revision view
			&& is_null($wgRequest->getVal('revision'))
			// bug #8311 - ensure user can see the page, otherwise extra error messages
			&& $wgArticle->userCanRead())
	{
		// get user who owns dashboard
		$username = urldecode($wgTitle->getPartialUrl());
		$User = null;

		// if has underscore, try finding name with spaces first
		if (strpos($username, '_') !== false)
		{
			$usernameSpaces = str_replace('_', ' ', $username);
			$User = DekiUser::newFromText($usernameSpaces);
		}

		// load the default username
		$User = is_null($User) ? DekiUser::newFromText($username) : $User;

		// only fire dashboard for root user page
		$dashboardPluginResult = DekiPlugin::executeHook(Hooks::USER_DASHBOARD, array($User));
	}

	if ($specialPluginResult > 0)
	{
		// noop, plugin should have already rendered html
	}
	else if ($dashboardPluginResult > 0)
	{
		// dashboard renders html
	} 
	else
	{
		switch( $wgTitle->getNamespace() ) {
			case NS_ATTACHMENT:
				require_once('Attach.php');
				if (AttachFile::execute( $wgTitle, $action ))
				return;
				break;
			default:
				$wgArticle = new Article( $wgTitle );
		}

		# MT ursm: edit a new article by default
		if ($action == 'view' && $wgArticle->getID() <= 0 && $wgTitle->isEditable() && $wgArticle->userCanCreate())
		{
			$action = 'edit';
		}

		// bugfix #6855: Itâ€™s possible to create Talk page without parent page
		if ($action == 'edit' && $wgArticle->getID() <= 0 && $wgTitle->getNamespace() == NS_TALK)
		{
			// determine if the talk parent exists
			$Title = Title::newFromText($wgTitle->getText());
			$Article = new Article($Title);
			if ($Article->getID() <= 0)
			{
				DekiMessage::error(wfMsg('Article.Error.cannot-create-talk'));
				$wgOut->redirectHome();
			}
		}

		if ($action == 'edit' && $wgArticle->getId() > 0 && !$wgArticle->userCanEdit()) {
			$action = 'view';
		}

		switch( $action ) {
			case 'noaction':
				break;
			case 'print':
			case 'view':
			case 'diff':
				/* todo: this should split off into its own Article method when we refactor article */
				$wgArticle->view();
				break;

				// post only action for revision hiding
			case 'historysubmit':
				$Request = DekiRequest::getInstance();
				// action is for post only
				if (!$Request->isPost())
				{
					$wgOut->redirectHome();
					break;
				}

				// determine if the user is changing a revision or viewing a diff
				$revChange = $Request->getVal('revchange');
				if (empty($revChange))
				{
					// guerrics: redirect to non-posted url
					$revision = $Request->getInt('revision');
					$diff = $Request->getInt('diff');
					$query = 'action=diff&revision='.$revision.'&diff='.$diff;
					$wgOut->redirect($wgTitle->getFullURL($query));
					break;
				}

				// else, revision show/hide fall through to history
			case 'history':
				require_once( 'includes/PageHistory.php' );
				$history = new PageHistory( $wgArticle );
				$history->history();
				break;

			case 'comment':
				$Title = clone $wgArticle->getTitle(); // making copies...
				if (DekiPlugin::HANDLED_HALT != DekiPlugin::executeHook(Hooks::MAIN_ACTION_COMMENT, array($Title)))
				{
					$editor = new CommentPage($Title);
					$editor->submit();
				}
				break;

			case 'watch':
			case 'unwatch':
				//		case 'delete':
			case 'revert':
			case 'rollback':
			case 'addsubpage':
				$wgArticle->$action();
				break;
			case 'export':
				$wgOut->mExport = true;
				$wgOut->mExportType = strtolower($wgRequest->getVal('type'));
				$wgArticle->view();
				if ($wgRequest->getVal('type') == 'pdf') {
					$wgOut->mExportType == 'pdf';
				}
				break;
			case 'submit':
				if( !$wgCommandLineMode && !$wgRequest->checkSessionCookie() ) {
					DekiUser::setupSession();
				}
				# Continue...
			case 'edit':
			case 'source':
				require_once( 'includes/EditPage.php' );

				if ($action != 'submit')
				{
					$wgArticle->view();
				}

				$editor = new EditPage( $wgArticle );
				if ( $action == 'submit' )
				{
					$editor->submit();
				}
				break;

			default:
				$result = DekiPlugin::executeHook(Hooks::MAIN_ACTION, array($action, $wgTitle, $wgArticle));
				if ($result == DekiPlugin::UNHANDLED || $result == DekiPlugin::UNREGISTERED)
				{
					$wgOut->errorpage('System.error.error', 'Article.Error.unknown-action-specified');
				}
		}
	}
}

if ($action != 'export')
{
	// what's new feed
	$RecentChangesTitle = Title::makeTitle( NS_SPECIAL, 'Recentchanges' );
	$wgOut->addLink(array(
		'rel' => 'alternate',
		'type' => 'application/rss+xml',
		'title' => wfMsg('Page.ListRss.whats-new-feed'),
		'href' => $RecentChangesTitle->getLocalURL('feed=rss')
	));
}

wfProfileOut( 'main-action' );

wfProfileIn( 'main-cleanup' );
// allow plugins to add or modify content of the page
DekiPlugin::executeHook(Hooks::MAIN_PROCESS_OUTPUT, array($wgOut));
$wgOut->output();
wfProfileOut( 'main-cleanup' );

logProfilingData();
$wgDatabase->close();
