#!/usr/bin/env ruby

require 'erb'

def usage
  STDERR.puts """
  Usage:

generate_delegate_ios.rb somedll.dll Fully.Qualified.ClassName

  Output:

  ClassName.cs

  """
end

def class_name(full_classname)
  full_classname.gsub(/.*\./, '')
end

def namespace_name(full_classname)
  full_classname.gsub(/\.[^\.]+$/, '')
end

def method_name(signature) 
  /.* ([^\.]+) \(/.match(signature)[1]
end

def return_type(signature)
  /.* (\S+) \S+ \(/.match(signature)[1]
end

def param_type(param_text)
  /(\S+) \S+ *$/.match(param_text)[1]
end

def formal_name(param_text)
  / (\S+)$/.match(param_text)[1]
end

def method_params(signature)
  (/\((.*)\)/.match(signature)[1]).split(',')
end

def formal_param_names(signature)
  method_params(signature).map {|x| formal_name(x) }
end

def typeparam_for_observable(class_name, signature)
  params = method_params(signature)

  return "Unit" if params.length == 0
  return param_type(params[0]) if params.length == 1

  return "#{class_name}#{method_name(signature)}Params"
end

def needs_unique_type?(signature)
  ret = (method_params(signature).length > 1)
  ret
end

def onnext_observable_value(class_name, signature)
  params = method_params(signature)
  formals = formal_param_names(signature)

  return "new Unit()" if params.length == 0
  return formals[0] if params.length == 1

  props = formals.map{|x| "#{x} = #{x}"}.join(', ')
  "new #{typeparam_for_observable(class_name, signature)}() { #{props} }"
end

@template = """
/*
 * DO NOT EDIT THIS FILE
 *
 * Generated via generate_delegate_ios.rb - edit the template in there instead
 */

using System;
using System.Linq;
using System.Concurrency;
using System.Collections.Generic;
using ReactiveUI;
using MonoTouch.Foundation;
using <%= namespace_name(full_classname) %>;

namespace ReactiveUI.iOS 
{
  public <%= abstract %> partial class <%= class_name(full_classname) %>Rx : <%= full_classname %>
  {
    <% constructor_signatures.each do |sig| %>
    public <%= class_name(full_classname) %>Rx(<%= (method_params(sig) + ['IScheduler sched = null']).join(',') %>) : base(<%= formal_param_names(sig).join(',') %>)
    {
      initialize(sched);
    }
    <% end %>

    void initialize(IScheduler sched)
    {
      var _sched = sched ?? RxApp.DeferredScheduler;

      <% method_signatures.each do |sig| %>
      _<%= method_name(sig) %> = new Subject<<%= typeparam_for_observable(class_name(full_classname), sig) %>>(_sched);
      <% end %>
    }

    <% method_signatures.each do |sig| %>
    Subject<<%= typeparam_for_observable(class_name(full_classname), sig) %>> _<%= method_name(sig) %>;
    public override void <%= method_name(sig) %>(<%= method_params(sig).join(',') %>)
    {
      _<%= method_name(sig) %>.OnNext(<%= onnext_observable_value(class_name(full_classname), sig) %>);
    }

    public Subject<<%= typeparam_for_observable(class_name(full_classname), sig) %>> On<%= method_name(sig) %> {
      get { return _<%= method_name(sig) %>; }
    }
    <% end %>
  }

  <% method_signatures.select{|sig| needs_unique_type?(sig)}.each do |sig| %>
  public sealed class <%= typeparam_for_observable(class_name(full_classname), sig) %>
  { 
    <% method_params(sig).each do |param| %>
    public <%= param_type(param) %> <%= formal_name(param) %> {get; internal set;} 
    <% end %>
  }
  <% end %>
}

"""

def main(args)
  unless args.length == 2
    usage()
    exit 1
  end

  full_classname = args[1]

  class_header = `monop -r:#{args[0]} #{args[1]} -d`

  abstract = class_header.include?('abstract') ? 'abstract' : ''
  method_signatures = class_header.lines.select {|x| x.include?('virtual') and x.include?('public')}.select{|x| return_type(x) == 'void'}
  constructor_signatures = class_header.lines.select{|x| x.include?(class_name(full_classname) + " ") and not x.include?('class')}

  erb = ERB.new(@template)
  output = erb.result(binding)
  File.open("#{class_name(full_classname)}.cs", 'w') {|f| f.write(output)}
end


main(ARGV)
